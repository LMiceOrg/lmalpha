%% !TeX root = ./lmalpha.tex
%% !TEX TS-program = xelatex
%% !TEX encoding = UTF-8 Unicode

% 系统简介
\chapter{简介}


\large{LMALPHA}\footnote{LMALPHA:Alpha因子设计与执行系统名称。}
\normalsize\phantom{L}
是辅助研究员与开发员设计验证Alpha策略的一套软件系统。\\

系统主要功能特征是简化Alpha因子模型设计与验证流程，主要技术特征是实现高性能执行
因子计算与分析。\\

系统由数据子系统、因子计算函数库、辅助函数库、调用管理程序、分析结果仪表盘
程序等5个子系统组成。\\

系统支持结构化数据与非结构化数据访问、支持常用统计与计算函数、支持后台批处理模式
连续运行。\\

形象来说，将一个策略想法轻松变成可以高性能运行的验证程序，研究员将会获得极大的灵活性和工作效能。而痛苦的中间过程需要经历分析、设计、编码、调试、部署与运行等诸多环节，其中还包括掌握计算机体系结构知识、数据库知识、CPP语言知识、程序设计知识、各类周边库知识、数学工具与模型知识等等。通过LMAlpha，让掌握模型知识的研究员不假程序员之手编写高性能因子计算程序成为可能。\\

\large{主要功能}\normalsize{}—— \\

实现快速验证Alpha因子，给研究员与基金管理人员提供及时可靠的策略执行与策略调整的量化依据。


%设计原理
\chapter{设计原理}

\large{系统设计一般原理}\normalsize{} \\

一切系统设计的出发点，首先就要有正确的目标定位。系统设计的差异性，核心表现在不同系统的主要矛盾
的差异性上--也即是抓系统主要特性。更进一步，在现在以及可预见的未来，量化分析已经且仍会是交易领域
主流共识的这一共性条件下，系统设计应强调那一方面能力，将决定我们在这个领域最终的市场表现--也即
交易领域的技术认识。\\

对于LMAlpha系统，目标定位是满足研究员对因子验证程序的便捷化开发与高性能执行。同时提升开发效率
与执行效率—— 一切系统设计皆须从此出发点开展。\\

而开发效率与执行效率的矛盾恰好是通用程序设计语言的主要矛盾，系统要提升效率，需要在“通用”二字上
做足文章，方法就是引入领域概念与领域模型\footnote{领域概念与领域模型：Domain Specified
Modeling，提供对相关领域概念与对象的抽象与封装，简化设计人员的对领域问题的规划与描述难度。}
，通过牺牲部分通用性而强调和突出特定功能。
变通用为专用——系统主要特性设计从此处展开。\\

在功能设计与约束条件发生冲突时，系统设计做不到开发与执行效率得而兼之，取舍之间的道理不会是一成
不变，不变的原理是设计依据需要符合交易领域的技术发展逻辑。我们对交易领域设计技术与执行
技术的认识和发展展望——规范系统一般性设计依据。\\

考虑到alpha项目开展的风险较大，并且项目需求与系统功能还没有明确一个清晰的完整的定义，因此系
统设计一定要符合当前实际需求，按照需求实际通过迭代式方法设计与实现系统，当需求切实发生变动时实
时修改设计。
KISS原则\footnote{KISS原则: Keep It Simple and Stupid, 不是不要优化系统，而是要避免过度优
化和过早优化。}
加Agile原则\footnote{Aglie原则: 敏捷设计犹如动态规划算法，在设计迭代过程中，每一步选取最优
方案，从而达到全局最优。}
——采用增量化设计技术，同时避免过度的设计。 \\


\large{总结}\normalsize{}
\begin{enumerate}
\item 同时提升开发效率与执行效率----系统设计皆须从此出发点开展。
\item 变通用为专用----系统主要特性设计从此处展开。
\item 符合我们对交易领域设计技术与执行技术的认识和发展展望----规范系统一般性设计依据。
\item KISS原则加Agile原则--采用增量化设计技术，同时避免过度的设计。
\end{enumerate}

——以上。


\section{状态机}

描述系统活动视图，TBD。

\section{框架与库}
描述系统组成与功能视图，TBD。

\chapter{总体设计}

\section{LMAlpha总体设计}

\footnote{立场：通过软件手段与系统技术满足永无止境的因子设计与策略验证需要。}
基本需求来源于永无止境的因子设计与策略验证需要。我们通过引入新的软件手段与系统技术,不断
设计与重构本系统以服务于这个需求。\\

\footnote{观点：系统服务于研究员与交易员的工作需要。}
基本观点是改进目前的因子验证与策略设计方法。Alpha因子设计的主要目的是实现研究思路的快
速验证，提高研究员效率，同时也可以作为交易过程中
策略验证与改进的辅助手段。\\

\footnote{方法：基于C++语言基础环境实现领域化系统设计。}
基本方法是引入其他领域成熟技术结合本领域的需求实际。Alpha策略应用前景非常看好，
进而带动了对因子与策略设计验证的系统需求。基于C++的软件设计开发，由于其
开发效率与执行效率相对均较高，提供复杂系统抽象与封装的设计方法等特性，是目前乃至未来一段时间内
主要的高性能开发通用程序语言。提高因子计算性能既提高Alpha策略的研究能力，能为基于Alpha策略
的交易提高市场机会。在另一方面，通过引入领域概念与领域模型等元语言技术
\footnote{元语言：Meta Language，简单来说就是构建语言的语言}，研究员可以使用自己熟悉的
概念与术语直接操作系统，将极大简化软件使用学习与编程难度，从而提高因子研究的效率。
\\

系统总的设计的主要目的是服务于因子设计，主要特性是高效率\footnote{这里效率指的总体效率，
包含因子的开发效率和执行效率}。\\

\section{需求与分析}

第一阶段系统设计依据的用户需求列表，如图 \ref{fig:s1-userstories} 所示。需求总体可以分为
功能性需求与非功能性需求两大类。其中功能性需求有6个，包含1个规范技术标准和其他5个需
要设计开发的功能。非功能性需求有3个，包含1个项目管理规范和其他2个需要执行项目管理的需求。\\

系统需求勾画了系统的三个基本组成部分与工作模式，如图\ref{fig:s1-system_structure}所示。系统划分为三个子系统，项目管理，配置管理与协同工作。 \\


系统工作模式采用每日Scrum\footnote{Scrum: IEEE Scrum是敏捷开发的一种国际标准。}方式
组织与开展，它连通协同工作与项目管理，而项目管理则同时辅助配置管理。通过协同工作，实现项目状态同步，并将当日发生的问题反馈到开发者，以便于更新设计。\\



\section{功能设计目标}

基于对需求的分析，第一阶段的设计目标是实现一个最小化的验证系统。系统规范技术开发标准
，包括统一使用VS2015
\footnote{VS2015:Visual Studio 2015，微软公司开发工具环境。}集成开发环境，
工程字符串处理采用Unicode编码格式，编译目标架构是x64环境等等。系统因子开发通过VS2015进行，不
再单独设计因子开发程序。剩余功能需求和与之相对应的设计目标如下:



\begin{enumerate}

\item 实现最基本的因子执行功能——设计基于UI
\label{func_ui}
\footnote{UI:User Interface，用户交互界面。}
的因子模型调用模块。

\item 实现最基本的数据计算功能——设计包含线性回归函数与残差计算功能的因子设计辅助模块。
\label{func_lmlib}

\item 实现最基本因子开发功能——设计基于C++11标准高层调用接口API模块。
\label{func_lmapi}

\item 实现最基本因子结果展示功能——设计基于Excel+Python的分析模版，实现因子计算结果数据的
快速查询分析与可视化图表展示。
\label{func_dashboard}
\end{enumerate}

\begin{figure}[ht]
\centering
\includegraphics[width=14cm]{sprint1-userstories.png}
\caption{LMAlpha系统sprint1期间用户需求}
\label{fig:s1-userstories}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[height=10cm]{system_structure.png}
    \caption{LMAlpha系统组成与工作模式}
    \label{fig:s1-system_structure}
\end{figure}



\section{系统设计的项目约束}

系统功能划分来源于两次面对面沟通，第一阶段预计开发时间为1周，开发团队4人，主要功能实现1人，如图
\ref{fig:s1-teamview}所示。
因此不得不考虑压缩需求和简化设计实现。 \\

\begin{figure}[ht]
\centering
\includegraphics[width=14cm]{sprint1-teamview.png}
\caption{LMAlpha系统sprint1团队一览}
\label{fig:s1-teamview}
\end{figure}

\section{系统功能设计调整}

对于功能需求\ref{func_ui}，在设计时不得不舍去GUI\footnote{GUI:Graphics User Interface，图形用户界面。}目标，转而去设计实现更简单的CUI\footnote{CUI:Console User Interface，控制台用户界面。}。\\

对于功能需求\ref{func_lmlib}，在设计时考虑放弃对TA-lib的封装，转而对更为广泛使用的GSL库
的封装。\\

对于功能需求\ref{func_lmapi}，在设计时并没有更多领域概念与领域模型考虑，仅使用C++语言完成
5类基础功能的API接口封装。\\

对于功能需求\ref{func_dashboard}，没有硬性做为本阶段设置目标要求。

\section{项目管理设计}

基于对需求的分析，第一阶段的项目管理目标是摸索一套有效满足项目管理规范，且方便各方理解掌握
与参与的项目管理工具与活动。系统依据的项目管理规范主要考虑风险管理需要与安全管理需要，因此
严格文档及代码的使用和访问范围。项目管理工具的设计，主要基于Excel开发包含三个视图的轻
量化管理模版。
\begin{enumerate}

\item 用户故事——设计规范化的用户需求生成结构。
如\ref{fig:s1-p-userstories}所示。

\item 工作内容——设计对应用户故事的工作任务表，以便于协同工作和状态追踪。
如图\ref{fig:s1-p-backlog}所示。

\item 燃尽图——设计基本统计指标和图表管理项目风险与目标。
如图\ref{fig:s1-p-burndown}所示。

\end{enumerate}

\begin{figure}[htbp]
\centering
\subfigure[用户故事]{
\begin{minipage}[t]{0.32\linewidth}
\centering
\includegraphics[width=5cm,height=4cm]{sprint1-userstories.png}
\label{fig:s1-p-userstories}
% \caption{LMAlpha系统sprint1工作任务表}
\end{minipage}%
}%
\subfigure[工作任务]{
\begin{minipage}[t]{0.32\linewidth}
\centering
\includegraphics[width=5cm,height=4cm]{sprint1-backlog.png}
\label{fig:s1-p-backlog}
% \caption{LMAlpha系统sprint1工作任务表}
\end{minipage}%
}%
\subfigure[燃尽图]{
\begin{minipage}[t]{0.32\linewidth}
\centering
\includegraphics[width=5cm,height=4cm]{sprint1-burndown.png}
\label{fig:s1-p-burndown}
%\caption{LMAlpha系统sprint1燃尽图}
\end{minipage}%
}%
\caption{LMAlpha项目管理工具设计}
\end{figure}

\chapter{数据库详细设计}
\LARGE{BONA提供}\normalsize。

\chapter{因子库详细设计}

\section{技术架构设计}

\large{因子库}\normalsize 设计时考虑实现3层API，
如图\ref{fig:s1-lmapi_structure}所示。
底层API\footnote{底层API:接口形式为C语言函数原型，调用者通过全局静态函数实现手动管理
生存周期与内存操作。}
实现内存操作与对象生命周期的手动管理。
中层API\footnote{中层API:接口形式为C++语言类原型，调用者通过对象公共成员函数实现功能。}
实现基于智能指针的对象生命周期管理与类方法调用。
高层API\footnote{高层API:接口形式为C++匿名函数与宏，调用者通过类型无关、
状态无关的语法实现功能}
实现领域知识、计算逻辑与操作过程的管理。\\

设计目的——同时提高开发效率与执行效率。研究员根据自己对开发技术的掌握能力，选择不同层级的API
开发因子库，在性能不得不继续提升的使
用场合，选择低级别的API来实现更精细的程序访问控制和效率优化。 \\

\begin{figure}[htbp]
\centering
\includegraphics[width=14cm]{sprint1-lmapi_structure.png}
\caption{因子库技术架构设计}
\label{fig:s1-lmapi_structure}
\end{figure}

\section{接口组成设计}

\large{因子库}\normalsize 接口包含5个组成部分，如图\ref{fig:s1-lmapi_component}所示。
各接口在因子计算程序中的作用如下：\\
\begin{enumerate}
\item 控制台日志组件\footnote{控制台日志组件：向控制台输出格式化、彩色化的运行日志信息}：实现因子计算程序的功能调试与执行状态检测。

\item 配置文件组件：实现因子计算程序的参数化执行和调试。

\item 时间序列数据组件：实现因子计算程序的二进制的K线数据，Tick数据访问。

\item SQL数据库访问组件：实现因子计算程序的动态查询SQLServer 2008数据的功能。

\item 计算结果存储组件：实现因子计算程序的状态存储与计算结果存储。

\end{enumerate}

\begin{figure}[htbp]
\centering
\includegraphics[width=14cm]{sprint1-lmapi_component.png}
\caption{因子库接口组成设计}
\label{fig:s1-lmapi_component}
\end{figure}

\section{因子库初始化}

研究员通过使用高层API，完全避免因子库初始化的细节和具体工作，程序只需要在因子计算程序
头调用因子库初始化接口即可完成因子库的初始化工作。\\
\begin{lstlisting}[caption=高层API接口]
    LMAPI_INIT("cfg_name");//$# \makeremark{初始化因子库，配置控制台输出格式，打开配置文件} $

    // Do other things ...

    //函数结束 //$#\makeremark{自动管理因子库对象资源回收} $
\end{lstlisting}
\showremarks


% 结束高层API文档
\highlevelapiend

因子库中层API定义如\ref{lmapi_api}所示。

\lstinputlisting[label={lmapi_api},caption=因子库-中层API, firstline=242, lastline=271,morekeywords={vector,string,config_open,get_array_float64,get_int}]{../lmapi/lmapi.h}


更进一步，使用C++智能指针可以简化初始化工作，并能够避免因为忘记释放而出现的内存泄漏问题。\\

\begin{lstlisting}[caption=中层API接口加智能指针]
    auto api = std::shared_ptr<lmapi::lmapi>(new lmapi::lmapi());//$# \makeremark{构造基于智能指针的因子库对象} $

    // Do other things ...

    //函数结束 //$#\makeremark{C++自动释放因子库对象} $
\end{lstlisting}
\showremarks

因子库实现为线程安全，因此从实践上，一个因子计算程序只需要初始化一个因子库的实例。因子库初始
化时，需要调用类lmapi构造函数。在使用完成后，需要调用其析构函数以完成资源回收。\\

\begin{lstlisting}[caption=中层API接口]
    auto api = new lmapi::lmapi(); //$# \makeremark{构造因子库对象，使用auto作为变量类型} $

    // Do other things ...

    delete api;//$# \makeremark{析构因子库对象} $
\end{lstlisting}
\showremarks


\section{控制台日志API}

当使用高层API时，控制台日志随因子库同时已被初始化。在因子计算程序代码中可以通过
如下高层API输出日志：\\

\begin{lstlisting}[caption=高层API接口,morekeywords={INFO,LOG,DEBUG,WARNING,CRITICAL,ERROR}]
    // 日志信息
    LOG("start run\n");
    // 输出：start run

    // 提示信息
    INFO("%s :%lf\n", L"因子计算结果", 6.123);
    // 输出：因子计算结果 :6.123


    // 调试信息
    DEBUG("%ls %s at(%d) : %ls\n", L"执行文件", __FILE__, __LINE__, L"发生错误");
    // 输出：执行文件D:\work\myfactor\main.cpp at(166) : 发生错误

    // 告警信息
    WARNING("%ls\n", L"注意，运行时间超过预期");
    // 输出：注意，运行时间超过预期

    // 危急信息
    CRITICAL("%ls\n", L"浮点计算出现nan结果");
    // 输出：浮点计算出现nan结果

    // 错误信息
    ERROR("%s\n", L"内存告罄，程序强制退出");
    // 输出：内存告罄，程序强制退出



\end{lstlisting}



% 结束高层API文档
\highlevelapiend

控制台日志中层API定义如\ref{console_api}所示。

\lstinputlisting[label={console_api},caption=控制台日志-中层API, firstline=168, lastline=182,morekeywords={vector,string,config_open,get_array_float64,get_int}]{../lmapi/lmapi.h}

控制台日志类不能直接被初始化,需要通过因子库动态创建控制台日子对象。\\

\begin{lstlisting}[caption=中层API接口加智能指针]
    auto log = std::shared_ptr<lmapi::console>(new api->console_open(type));//$# \makeremark{构造基于智能指针的控制台日志对象\newline%
    type参数为\emph{\color{red}lmapi\_console\_type}枚举类型的组合\newline%
    \newline%
    {\color{blue}%
        LMAPI\_LOG\_ALL = 0,\newline%
        LMAPI\_LOG\_DATETIME = 1 << 0, \newline %
        LMAPI\_LOG\_PROCESS = 1 << 1,\newline%
        LMAPI\_LOG\_THREAD = 1 << 2 \newline%
    }%
} $

    // 向控制台输出信息
    log->info("%ls : %ls\n", L"因子计算", L"执行n参数读取");

    //函数结束 //$#\makeremark{C++自动释放控制台日志对象} $
\end{lstlisting}
\showremarks

当type值为0时，格式相当于输出所有可配置参数。如当前线程设定了名称，这输出线程名称，否则输出线程ID。type的组合设置通过一个例子说明:如需要控制台日志对象输出当前进程号与线程号，当不需要输出时间的是否，type的设置如下：\\

\begin{minipage}{0.8\linewidth}
\centering
{\color{red} int \color{black} type = \color{blue}LMAPI\_LOG\_PROCESS | LMAPI\_LOG\_THREAD};\newline

\end{minipage}

因子计算程序可以同时拥有多个控制台日志对象，每日志对象的输出格式类型可以不同。

\section{配置文件读取API}
当使用高层API时，配置文件读取已经随因子库同时初始化。配置文件支持json,xml两种格式，在因子计算程序中可以通过如下高层API访问参数配置：

\begin{lstlisting}[caption=高层API接口-获取基本参数类型,morekeywords={CFG_INT,CFG_DBL,CFG_STR}]
    // 获取整型参数
    int iparam = CFG_INT("factor.backtesting.start_date");//$# %
    \makeremark{从配置文件读取参数,以.分隔嵌套对象的参数读取\newline%
    如配置文件为json格式，配置文件中对象结构如下\newline%
    {\color{blue}\newline%
        \{"factor":\newline%
            \hspace*{10mm}\{"backtesting":\newline%
                \hspace*{20mm}\{"start\_date":20180101\newline %
                \hspace*{20mm} ...\newline%
                \hspace*{20mm}\}\newline%
            \hspace*{10mm}\}\newline%
        \}\newline%
    }\newline%
    如配置文件为xml格式，则配置文件中可以有两种相对应的对象结构\newline%
    \newline%
    xml不包含属性格式如下:%
    {\color{blue}\newline%
    <factor>\newline%
        \hspace*{10mm}<backtesting>\newline%
            \hspace*{20mm}<start\_date>20180101</start\_date>\newline%
        \hspace*{10mm}</backtesting>\newline%
    </factor>\newline%
    }\newline%
    xml包含属性格式如下:%
    {\color{blue}\newline%
    <factor>\newline%
        \hspace*{10mm}<backtesting start\_date="20180101">\newline%
        \hspace*{10mm}</backtesting>\newline%
    </factor>\newline%
    }\newline%
}$

    // 获取浮点数参数
    double fparam = CFG_DBL("factor.weight");

    // 获取字符串参数
    auto sparam = CFG_STR("factor.name");



\end{lstlisting}
\showremarks\hspace*{0mm}


因子计算程序可以通过如下高层API访问数组参数配置:

\begin{lstlisting}[caption=高层API接口-获取数组参数类型,morekeywords={CFG_ARR_ARR_INT,CFG_ARR_DBL,CFG_ARR_STR}]
    // 获取整型数组参数
    int iparam = CFG_ARR_INT("factor.backtesting.index\_list");//$# %
\makeremark{从配置文件读取数组参数,以.分隔嵌套对象的参数读取\newline%
如配置文件为json格式，配置文件中对象结构如下\newline%
{\color{blue}\newline%
    \{"factor":\newline%
        \hspace*{10mm}\{"backtesting":\newline%
            \hspace*{20mm}\{"index\_list":\newline %
            \hspace*{30mm} [500001, 500002, 500003, ...]\newline%
            \hspace*{20mm}\}\newline%
        \hspace*{10mm}\}\newline%
    \}\newline%
}\newline%
如配置文件为xml格式，则配置文件中可以有两种相对应的对象结构\newline%
\newline%
xml不包含属性格式如下:%
{\color{blue}\newline%
<factor>\newline%
    \hspace*{10mm}<backtesting>\newline%
        \hspace*{20mm}<index\_list>500001</index\_list>\newline%
        \hspace*{20mm}<index\_list>500002</index\_list>\newline%
        \hspace*{20mm}<index\_list>500003</index\_list>\newline%
    \hspace*{10mm}</backtesting>\newline%
</factor>\newline%
}\newline%
xml包含属性格式如下:%
{\color{blue}\newline%
<factor>\newline%
    \hspace*{10mm}<backtesting index\_list="500001"></backtesting>\newline%
    \hspace*{10mm}<backtesting index\_list="500002"></backtesting>\newline%
    \hspace*{10mm}<backtesting index\_list="500003"></backtesting>\newline%
</factor>\newline%
}\newline%
}$

    // 获取浮点数组参数
    double fparam = CFG_ARR_DBL("factor.seeds");

    // 获取字符串数组参数
    auto sparam = CFG_ARR_STR("factor.backtesting.stock\_list");



\end{lstlisting}
\showremarks\hspace*{0mm}

% 结束高层API文档
\highlevelapiend

配置文件中层API定义如\ref{config_api}所示。

\lstinputlisting[label={config_api},caption=配置文件-中层API, firstline=140, lastline=167,morekeywords={vector,string,config_open,get_array_float64,get_int}]{../lmapi/lmapi.h}

在因子计算程序中可以同时打开多个配置文件访问参数，也可以同时打开不同类型配置文件。这个时候，需要手动构造配置文件对象，使用智能指针的构造方法如下:

\begin{lstlisting}[caption=中层API接口-智能指针, morekeywords={vector,string,config_open,get_array_float64,get_int}]
    // 构造配置文件对象
    auto cfg = std::shared_ptr<lmapi::config>(new api->config_open(cfg_name));//$# \makeremark{构造基于智能指针的配置文件对象\newline%
cfg\_name参数:配置文件路径 } $

    // 获取整型参数
    int iparam = cfg->get_int("factor.stock.size");

    // 获取字符串参数
    std::string sparam =cfg->get_string("factor.name");

    // 获取浮点数组参数
    std::vector<double> real_list = cfg->get_array_float64("factor.data.value_list");

    // 获取字符串数组参数
    std::vector<std::string> > stock_list = cfg->get_array_string("factor.backtesting.stock_list");

    // 离开访问范围 //$# \makeremark{C++自动释放配置文件对象打开的资源} $

\end{lstlisting}
\showremarks\hspace*{0mm}


\section{时间序列读取API}
当使用高层API时，在因子计算程序代码中可以通过\ref{hla_serial} 高层API读取时间序列数据：
\begin{lstlisting}[label={hla_serial},caption=高层API接口, morekeywords={vector,string,config_open,get_array_float64,get_int}]

    // 读取K线数据
    auto kdata_list = ARR_KDATA(stock_list, type, start_date, end_date); //$# %
    \makeremark{%
    读取并返回K线数据\newline%
    stock\_list参数：股票代码数组，字符串数组\newline%
    type参数: K线数据，枚举类型，支持如下取值：\newline%
    {\color{blue}\newline%
    KMIN1   1分钟K线数据\newline%
    KMIN5   5分钟K线数据\newline%
    KMIN15  15分钟K线数据\newline%
    KMIN30  30分钟K线数据\newline%
    KMIN60  60分钟K线数据\newline%
    KMIN120 120分钟K线数据\newline%
    }%
    start\_date参数：数据的开始日期，整型,格式为:\newline%
    yyyymmdd 如：20170101\newline%
    end\_date参数：数据的结束日期，整型，格式与start\_date相同\newline%
    } $

    // 读取tick数据
    auto tick_list = ARR_TICK(stock_list, start_date, end_date); //$# %
    \makeremark{%
    读取并返回TICK数据\newline%
    stock\_list参数：股票代码数组，字符串数组\newline%
    start\_date参数：数据的开始日期，整型,格式为:\newline%
    yyyymmdd 如：20170101\newline%
    end\_date参数：数据的结束日期，整型，格式与start\_date相同\newline%
    } $

\end{lstlisting}
\showremarks\hspace*{0mm}

API所返回的K线数据结果是一个二维数组，第一维对应股票代码，第二维对应K线数据。K线数据结构如\ref{kdata_struct}所示。

\lstinputlisting[label={kdata_struct},caption=K线数据结构定义, firstline=44, lastline=61, morekeywords={LM_ALPHA_HIGH_LEVEL_API}]{../include/lmstock.h}

API所返回的TICK数据结果同样是一个二维数组，第一维对应股票代码，第二维对应TICK数据。TICK数据结构\ref{tick_struct}所示。


\lstinputlisting[label={tick_struct},caption=TICK数据结构定义, firstline=7, lastline=42,morekeywords={LM_ALPHA_HIGH_LEVEL_API}]{../include/lmstock.h}

\highlevelapiend

中层API定义如\ref{serial_api}所示。相对于高层API，中层API提供了对单一股票代码的K线数据、TICK数据读取功能。

\lstinputlisting[label={serial_api},caption=时间序列数据-中层API, firstline=203, lastline=221,morekeywords={get_ticks,get_kdatas,get_tick,get_kdata,vector,lmtickdata,lmkdata,string}]{../lmapi/lmapi.h}


\section{SQL数据库查询API}

当使用高层API时，在因子计算程序代码中可以通过\ref{hla_sqlquery} 高层API查询MSSql Server2008数据库服务器，并返回数据集结果。

\begin{lstlisting}[label={hla_sqlquery},caption=高层API接口, morekeywords={SQLQUERY,ERROR}]

    // 查询数据库
    auto query = SQLQUERY("select top 15 TradingDay"
    ",SecuCode"
    ",Ashares"
    " from General.dbo.DailyQuote"
    " where  Flg =1 and "
    " (TradingDay between '2017-01-01' and '2018-12-31');"
    ); //$# %
    \makeremark{ %
    参数为SQL查询字符串\newline%
    query返回结果为二维数组结构，可以通过API rows, cols, get\_float64, get\_string等API访问返回值。\newline%
    当执行SQL发生异常的是否，通过API get\_error获取异常信息。\newline%
    } $

    // 使用返回值
    for (int i = 0; i < query->rows(); ++i) {
      for (int j = 0; j < query->cols(); ++j) {
        printf("  %s,", query->get_string(i, j).c_str());
      }
      printf("\n");
    }

    // 如查询服务器出现异常,则通过如下方式判断并输出调试信息
    if (!query->get_error().empty()) {
      ERROR("%s\n", query->get_error().c_str());
    }

\end{lstlisting}
\showremarks\hspace*{0mm}

\highlevelapiend

SQL数据库查询模块的返回对象定义如\ref{sql_api}所示。

\lstinputlisting[label={sql_api},caption=SQL数据库查询-中层API, firstline=183, lastline=202,morekeywords={get_error,get_int,get_int64,get_float64,get_string,rows, cols,string}]{../lmapi/lmapi.h}


\section{结果存储API}
因子库实现结构存储功能包括因子基本信息存储，因子计算结果存储，通过高层API调用如\ref{hla_factorresult}所示。

\begin{lstlisting}[label={hla_factorresult},caption=高层API接口, morekeywords={FACTOR_RESULT}]

    // 因子结果存储
    FACTOR_RESULT(name, stock_list, result_list); //$# \makeremark{ %
    因子结构存储\newline%
    name参数: 因子名称，字符串\newline%
    stock\_list参数：股票代码列表，字符串数组\newline%
    result\_list参数：因子计算结果列表，lmapi\_result\_data二维数组，第一维对应股票代码，第二维对应计算结果,定义如下\newline%
    {\color{blue}\newline%
    struct lmapi\_result\_data \{\newline%
    \hspace*{10mm}int date; //日期\newline%
    \hspace*{10mm}int time; //时间\newline%
    \hspace*{10mm}double value; //计算结果\newline%
    \}; %
    } %
    } $

\end{lstlisting}
\showremarks\hspace*{0mm}

\highlevelapiend

结果存储模块的对象定义如\ref{factorresult_api}所示。

\lstinputlisting[label={factorresult_api},caption=结果存储-中层API, firstline=221, lastline=241]{../lmapi/lmapi.h}


\chapter{辅助库详细设计}

    \LARGE{博文提供}\normalsize。
    \chapter{执行框架详细设计}
    \chapter{界面工具详细设计}
